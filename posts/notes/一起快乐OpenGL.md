---
title: 快乐OpenGL
date: 2024/9/12
---

# 为什么我们需要这个什么GL

1. 首先，它很帅......
2. 其次，当你要生成一些奇奇怪怪的图案来掩饰 ui 设计的不足时，单单的单线程（如 canvas），并不能为你提供足够的性能（一些需要暴力逻辑或逻辑太过暴力的地方容易爆炸）。
3. 而且，它很帅......

# 采用什么环境

## web方向

​	原生配置参考 gpt（bushi），暂时没有发现很好的资料。

​	不要求原生手搓建议使用 **three.js**。可以用对象的形式设置 **uniform**。

## c++

​	建议参考[ **Learn OpenGL**](https://learnopengl.com/Getting-started/OpenGL)，至少我认为讲的挺好的。

​	关于环境配置，众所周知，c++ 并没有自带大家喜闻乐见的其它语言（rust、js、go......）中广泛自带的**包管理器**，这也导致如果我们需要在 IDE（如 Visual Studio）中使用一个新的库（如 OpenGL 可以用到的 GLFW），需要进行繁杂的环境配置（非常痛苦，红温了）。

​	针对这点，我要向各位安利一个有微软本身出品的包管理器——[**vcpkg**]([github.com](https://github.com/microsoft/vcpkg))。帮助大家重回快乐。

# 代码的运行逻辑是什么样的

## GLFW

​	作为原生的 c++ 库，在这种情况下的简单逻辑就是 while 循环里套不断的处理输入，根据新数据修改传入**着色器**的数据，并重复渲染。

​	基本的着色器有**俩**，**顶点着色器**和**片段着色器**，其中顶点着色器，顾名思义，就是接取传入的顶点坐标并在转换后输出（不需要更多操作），之后片段着色器部分就会在顶点间进行自主的补间，并接收由上一着色器传来的数据，计算后输出。

### 基本的利用逻辑

#### 传入顶点数据

​	首先由于 OpenGL 是一个 3D 图形库，因此需要传入的坐标也都是 **3D** 的；其次，其中的数据是遵循**归一化设备坐标（NDC）**的，即范围在 `[-1.0, 1.0]` 之间。如下为一个三角形的顶点举例。

```glsl
float vertices[] = {
	-0.5f, -0.5f, 0.0f,
	0.5f, -0.5f, 0.0f,
	0.0f, 0.5f, 0.0f
}
```

![2D Normalized Device Coordinates as shown in a graph](https://learnopengl.com/img/getting-started/ndc.png)

> 上图来自learnopengl.com

------

