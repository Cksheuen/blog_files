### 当前的背景效率如何

<img src="C:\Users\Cksheuen\Documents\Tencent Files\2358644858\nt_qq\nt_data\Pic\2025-03\Ori\9984a475c435dfc2918da57c23bfd74b.png" alt="9984a475c435dfc2918da57c23bfd74b" style="zoom:25%;" /><img src="C:\Users\Cksheuen\Documents\Tencent Files\2358644858\nt_qq\nt_data\Pic\2025-03\Ori\a1233568e0d1a197fec419629b1980d1.png" alt="a1233568e0d1a197fec419629b1980d1" style="zoom:25%;" />

一言以蔽之，相当废物。但也没办法，毕竟没有建模审美/没有建模心情是有代价的（况且和正版写法存在巨大差距）。

对于这点，暂且画几个饼来构思一下优化。

### 饼

#### prefetch

当前存在首次使用时，INP 远超正常情况的可能，怀疑是 魔法/网络 不稳定导致第一次加载 wasm 模块时造成的，预计研究下 prefetch ~~偷吃一下用户的流量~~ 优化一下。

#### image缓存

两种主题的背景切换时，简洁的背景（basicBg）并不会有明显的卡顿，但是较复杂的（betterBg）在再次使用时仍然存在一瞬的卡顿（v-if）。

两个可以尝试的方案：

1. v-if 切换为 v-show，优点是心智负担小，简洁易实现，但是会增加初次渲染的时长，显然不是个好的想法。
2. 每次切换时缓存上一步的 betterBg 内容为 img ，并在下次切换时使用。预计两个问题待解决：
   1. 切换时时间是否对应（暴力判断下）
   2. 切换后避免重复渲染，传入 img 为 texture 和 判断用 uniform。

#### 数据缓存

每次的渲染过程花费大量计算量用于地形的重新计算，这一点完全可以避免，主要属性应该包括 视线落点（pos）、视点法向量（nor）、颜色（mal）等可供提取。

在当前不考虑摄像机移动的情况下，可以将这些数据存入 texture 或 FBO（帧缓冲对象）中，并在之后的渲染中加以使用，节省性能开支。

#### 剔除

当前页面中采用 betterBg 的情况下与 basicBg 情况下存在明显差距。betterBg 中的主题颜色无法通过在 js 中通过与 glsl 中类似的算法来获取，且其本身由于物体更为丰富（相对花花绿绿的），并不适合使用透明的文本框，这在一些时间点的 betterBg 下增加了很大的阅读负担（对眼睛不太友好）。

对此，可以选择将正常的 html 元素背景实化。同时这也在一定的 betterBg 上形成了一个不需要渲染的盲区，对此，可以通过暴力的方法获取它们的范围并传递给着色器，来抛弃这些部分的运算。

问题在于，比如列表区域，会存在先前剔除部分在最新情况下发生变化的情况，这就使得剔除部分终将被渲染，而这时我们对此仍然需要花费性能来修补。如果一下子出现大批需要渲染的区域，INP 仍然会相当恐怖。

但是我们在开发过程中可以注意到一下两点：

1. 在为 betterBg 设计时间切换的同时，存在 时钟与 betterBg 两个需要 gpu 渲染的存在。通过为 betterBg 设置节流，我们可以使得 时钟 运行更加的流畅。
2. basicBg 同样使用 gpu 渲染，但得益于其的逻辑相对简单，我们使用 requestAnimationFrame 为它进行 逐帧动画 时，并没有遇到卡顿的情形。

那么答案只有一个了，我们在页面的日常运行时采用节流方式逐步对 betterBg 进行预渲染，这样，在除了同步切换光影的情况下，想必就能将切换的性能大幅提高。

### 呱

以上内容均为构思，具体实现得等慢慢改，具体坑也得慢慢踩。